# Temimi 视频平台毕业答辩技术分析

## 项目概述

**项目名称**: Temimi 仿B站弹幕视频平台  
**技术栈**: Spring Boot 3 + Vue 3 + MySQL + WebSocket  
**项目规模**: 
- 后端: 132个Java文件，约15000行代码
- 前端: 96个Vue/JS文件，约8000行代码

---

## 一、核心技术架构

### 1.1 后端技术栈 (temimi-backend)

#### 核心框架
- **Spring Boot 3.2.5** (需要Java 17)
- **MyBatis-Plus 3.5.5** - ORM框架，简化数据库操作
- **MySQL 8.0** - 关系型数据库
- **WebSocket** - 实时通信（弹幕、聊天）

#### 安全认证
- **JWT (JSON Web Token)** - 无状态认证
- **Spring Security** - 密码加密（BCrypt）

#### 工具库
- **Hutool** - Java工具包
- **Fastjson2** - JSON序列化
- **MP4Parser** - 视频元数据解析
- **Aliyun OSS** - 对象存储服务

### 1.2 前端技术栈 (temimi-client)

#### 核心框架
- **Vue 3.5.18** - 渐进式JavaScript框架
- **Vite 7.1.12** - 现代化构建工具
- **Pinia 3.0.3** - 状态管理
- **Vue Router 4.6.3** - 路由管理

#### UI组件库
- **Element Plus 2.11.5** - UI组件库
- **Video.js 8.23.4** - 视频播放器

#### 实时通信
- **@stomp/stompjs** - WebSocket客户端
- **sockjs-client** - WebSocket兼容层

#### 其他工具
- **Axios** - HTTP客户端
- **SparkMD5** - 文件MD5计算（分片上传）
- **ECharts** - 数据可视化

---

## 二、核心功能实现与代码细节


### 2.1 JWT认证机制 ⭐⭐⭐

#### 实现位置
- 后端: `JwtAuthenticationTokenFilter.java`
- 配置: `application.yml` (jwt.secret, jwt.expire)

#### 核心代码逻辑

```java
// 1. 过滤器拦截请求
@Override
protected void doFilterInternal(HttpServletRequest request, 
                                HttpServletResponse response, 
                                FilterChain chain) {
    // 从请求头获取Token
    String token = getTokenFromRequest(request);
    
    if (token != null) {
        // 解析Token获取用户信息
        Integer uid = jwtUtil.getUserIdFromToken(token);
        String username = jwtUtil.getUsernameFromToken(token);
        Integer role = jwtUtil.getRoleFromToken(token);
        
        // 创建Spring Security认证对象
        UsernamePasswordAuthenticationToken authentication =
            new UsernamePasswordAuthenticationToken(uid, null, authorities);
        
        // 设置到SecurityContext
        SecurityContextHolder.getContext().setAuthentication(authentication);
    }
}
```

#### 技术要点
1. **OncePerRequestFilter**: 确保每个请求只执行一次过滤
2. **白名单机制**: 使用AntPathMatcher匹配路径，支持通配符
3. **双重存储**: 既存入SecurityContext（Spring标准），又存入request attribute（兼容现有代码）
4. **Token格式**: `Authorization: Bearer <token>`

#### 可能被问的问题
**Q1: 为什么使用JWT而不是Session？**
- JWT无状态，适合分布式系统
- 不需要服务器存储会话信息
- 支持跨域认证
- 减轻服务器压力

**Q2: JWT的安全性如何保证？**
- 使用HS512算法签名
- Secret密钥长度64字符以上
- Token有效期24小时
- HTTPS传输加密

**Q3: Token过期如何处理？**
- 前端拦截401状态码
- 清除本地Token
- 跳转登录页
- 关闭WebSocket连接


---

### 2.2 WebSocket实时弹幕系统 ⭐⭐⭐⭐⭐

#### 实现位置
- 后端: `DanmuWebSocketHandler.java`, `DanmuSessionManager.java`
- 前端: `PlayerWrapper.vue`, `DanmuBox.vue`
- 配置: `WebSocketConfig.java`

#### 架构设计

```
客户端                    服务端
  │                        │
  ├─ 建立连接 ──────────→ afterConnectionEstablished()
  │  /ws/danmu/{vid}       │
  │                        ├─ 提取视频ID
  │                        ├─ 绑定Session到视频池
  │                        └─ 广播观看人数
  │                        │
  ├─ 发送弹幕 ──────────→ handleTextMessage()
  │  {token, data}         │
  │                        ├─ 验证Token
  │                        ├─ 保存到数据库
  │                        └─ 广播给所有观看者
  │                        │
  │ ←────────────────── 接收弹幕
  │  {content, time, ...}  │
  │                        │
  └─ 断开连接 ──────────→ afterConnectionClosed()
                           └─ 移除Session
                           └─ 更新观看人数
```

#### 核心代码实现

**1. 连接建立**
```java
@Override
public void afterConnectionEstablished(WebSocketSession session) {
    // 从路径提取视频ID: /ws/danmu/{vid}
    String path = session.getUri().getPath();
    String[] pathParts = path.split("/");
    Integer vid = Integer.valueOf(pathParts[pathParts.length - 1]);
    
    // 绑定Session到视频池
    session.getAttributes().put("vid", vid);
    danmuSessionManager.bindSession(vid, session);
    
    // 广播当前观看人数
    broadcastPopulation(vid);
}
```

**2. 弹幕发送与广播**
```java
private void handleDanmuMessageFromFrontend(String dataJson, 
                                           WebSocketSession session, 
                                           Integer uid) {
    // 解析弹幕数据
    DanmuMessageDTO danmuDTO = objectMapper.readValue(dataJson, 
                                                     DanmuMessageDTO.class);
    
    // 创建弹幕对象
    Danmu danmu = new Danmu();
    danmu.setContent(danmuDTO.getContent());
    danmu.setVid(vid);
    danmu.setTimePoint(danmuDTO.getTime());
    danmu.setMode(danmuDTO.getMode());
    danmu.setColor(danmuDTO.getColor());
    danmu.setUid(uid);
    
    // 保存到数据库
    danmuService.sendDanmu(danmu, uid);
    
    // 广播给所有观看该视频的用户
    List<WebSocketSession> targetSessions = 
        danmuSessionManager.getSessionsByVid(vid);
    String broadcastJson = objectMapper.writeValueAsString(danmu);
    
    for (WebSocketSession targetSession : targetSessions) {
        if (targetSession.isOpen()) {
            targetSession.sendMessage(new TextMessage(broadcastJson));
        }
    }
}
```

**3. Session管理（会话池）**
```java
// DanmuSessionManager.java
private final Map<Integer, List<WebSocketSession>> videoSessionMap = 
    new ConcurrentHashMap<>();

public void bindSession(Integer vid, WebSocketSession session) {
    videoSessionMap.computeIfAbsent(vid, k -> new CopyOnWriteArrayList<>())
                   .add(session);
}

public List<WebSocketSession> getSessionsByVid(Integer vid) {
    return videoSessionMap.getOrDefault(vid, Collections.emptyList());
}
```

#### 技术要点

1. **会话池设计**: 使用ConcurrentHashMap存储视频ID到Session列表的映射
2. **线程安全**: CopyOnWriteArrayList保证并发安全
3. **Token验证**: 从WebSocket消息中提取Token，验证用户身份
4. **实时广播**: 一个用户发送弹幕，所有观看同一视频的用户立即收到
5. **观看人数统计**: 连接/断开时实时更新


#### 前端弹幕渲染

**弹幕发送**
```javascript
// PlayerWrapper.vue
const sendDanmu = () => {
    if (!danmuWs || danmuWs.readyState !== WebSocket.OPEN) {
        ElMessage.error('弹幕连接已断开');
        return;
    }
    
    const token = localStorage.getItem('teri_token');
    const message = {
        token: `Bearer ${token}`,
        data: {
            content: dmInput.value,
            time: currentTime.value,
            mode: dmStyle.mode,
            color: dmStyle.color,
            fontsize: dmStyle.fontsize
        }
    };
    
    danmuWs.send(JSON.stringify(message));
};
```

**弹幕接收与渲染**
```javascript
danmuWs.onmessage = (event) => {
    const danmu = JSON.parse(event.data);
    
    // 创建弹幕DOM元素
    const danmuElement = document.createElement('div');
    danmuElement.className = 'danmu-item';
    danmuElement.style.color = danmu.color;
    danmuElement.style.fontSize = danmu.fontsize + 'px';
    danmuElement.textContent = danmu.content;
    
    // 根据模式设置动画
    if (danmu.mode === 1) {
        // 滚动弹幕
        danmuElement.style.animation = 'danmu-scroll 10s linear';
    } else if (danmu.mode === 2) {
        // 顶部固定
        danmuElement.style.top = '10%';
    }
    
    // 添加到弹幕容器
    danmuContainer.appendChild(danmuElement);
};
```

#### 可能被问的问题

**Q1: WebSocket与HTTP的区别？**
- HTTP: 单向通信，客户端请求-服务器响应
- WebSocket: 双向通信，全双工，持久连接
- WebSocket适合实时性要求高的场景（弹幕、聊天）

**Q2: 如何保证弹幕的实时性？**
- WebSocket长连接，无需轮询
- 服务端收到弹幕立即广播
- 前端收到消息立即渲染
- 延迟通常在100ms以内

**Q3: 大量弹幕如何优化性能？**
- 前端: 虚拟滚动，只渲染可见区域
- 后端: 会话池管理，避免全局广播
- 数据库: 异步保存，不阻塞广播
- 限流: 用户发送频率限制

**Q4: WebSocket断线如何处理？**
- 心跳检测机制
- 自动重连（指数退避）
- 断线提示用户
- 重连后重新加载弹幕

---

### 2.3 视频播放器实现 ⭐⭐⭐⭐

#### 实现位置
- 组件: `PlayerWrapper.vue`
- 子组件: `PlayerProgress.vue`, `LoadingBuff.vue`

#### 核心功能

1. **视频播放控制**
```javascript
// 播放/暂停
const playVideo = () => {
    videoPlayer.value.play();
    pause.value = false;
};

const pauseVideo = () => {
    videoPlayer.value.pause();
    pause.value = true;
};

// 进度控制
const changeCurrentPer = (per) => {
    const newTime = duration.value * per;
    videoPlayer.value.currentTime = newTime;
    currentTime.value = newTime;
};
```

2. **缓冲进度显示**
```javascript
const updateBufferingBar = () => {
    const buffered = videoPlayer.value.buffered;
    if (buffered.length > 0) {
        const bufferedEnd = buffered.end(buffered.length - 1);
        bufferPer.value = bufferedEnd / duration.value;
    }
};
```

3. **全屏控制**
```javascript
const toggleFullscreen = () => {
    if (!document.fullscreenElement) {
        videoArea.value.requestFullscreen();
        screenType.value = 'fullscreen';
    } else {
        document.exitFullscreen();
        screenType.value = 'normal';
    }
};
```

4. **快捷键支持**
```javascript
const handleKeydown = (e) => {
    switch(e.key) {
        case ' ': // 空格 - 播放/暂停
            pause.value ? playVideo() : pauseVideo();
            break;
        case 'd': // d - 弹幕开关
            changeDanmu();
            break;
        case 'ArrowLeft': // 左箭头 - 后退5秒
            videoPlayer.value.currentTime -= 5;
            break;
        case 'ArrowRight': // 右箭头 - 前进5秒
            videoPlayer.value.currentTime += 5;
            break;
    }
};
```

#### 技术要点
- HTML5 Video API
- 自定义控制条UI
- 进度条拖拽交互
- 缓冲状态显示
- 全屏API
- 键盘快捷键


---

### 2.4 前端状态管理 (Pinia) ⭐⭐⭐

#### 实现位置
- `stores/user.js` - 用户状态
- `stores/video.js` - 视频状态
- `stores/comment.js` - 评论状态

#### 核心代码

```javascript
// stores/user.js
export const useUserStore = defineStore('user', {
  state: () => ({
    isLogin: false,
    user: {},
    msgUnread: [0, 0, 0, 0, 0, 0], // 未读消息数
    chatList: [],
    ws: null, // WebSocket实例
  }),

  getters: {
    userId: (state) => state.user?.uid,
    username: (state) => state.user?.username,
    avatar: (state) => state.user?.avatar,
    token: () => localStorage.getItem('teri_token'),
  },

  actions: {
    // 获取用户信息
    async getPersonalInfo() {
      const result = await http.get('/api/user/personal/info');
      if (result.data.code === 200) {
        this.updateUser(result.data.data);
        this.isLogin = true;
        this.claimDailyReward(); // 自动领取每日奖励
      }
    },

    // 登录
    async login(credentials) {
      const result = await http.post('/api/user/account/login', credentials);
      if (result.data.code === 200) {
        const token = result.data.data.token;
        localStorage.setItem('teri_token', token);
        await this.getPersonalInfo();
        return result.data;
      }
    },

    // 退出登录
    logout() {
      this.initData();
      if (this.ws) {
        this.ws.close();
        this.ws = null;
      }
      localStorage.removeItem('teri_token');
    },

    // WebSocket消息处理
    handleWsMessage(e) {
      const data = JSON.parse(e.data);
      
      switch (data.type) {
        case 'reply':
          this.msgUnread[0]++;
          break;
        case 'at':
          this.msgUnread[1]++;
          break;
        case 'whisper':
          this.handleWhisperMessage(data.data);
          break;
      }
    },
  },
});
```

#### 技术要点
1. **Composition API风格**: 使用defineStore定义store
2. **响应式状态**: state自动响应式
3. **计算属性**: getters类似Vue的computed
4. **异步操作**: actions支持async/await
5. **持久化**: 结合localStorage存储Token

#### 可能被问的问题

**Q1: Pinia与Vuex的区别？**
- Pinia更轻量，API更简洁
- 完全支持TypeScript
- 不需要mutations，直接修改state
- 更好的DevTools支持
- Vue 3官方推荐

**Q2: 为什么要用状态管理？**
- 跨组件共享状态
- 集中管理应用状态
- 便于调试和追踪
- 避免prop drilling

---

### 2.5 HTTP请求封装 ⭐⭐⭐

#### 实现位置
- `api/http.js`

#### 核心代码

```javascript
// 创建axios实例
const http = axios.create({
  baseURL: import.meta.env.VITE_API_BASE || '',
  timeout: 30000,
  withCredentials: true,
  headers: {
    'Content-Type': 'application/json'
  }
});

// 请求拦截器 - 添加Token
http.interceptors.request.use(
  config => {
    const token = localStorage.getItem('teri_token');
    if (token) {
      config.headers['Authorization'] = `Bearer ${token}`;
    }
    return config;
  },
  error => {
    return Promise.reject(error);
  }
);

// 响应拦截器 - 统一错误处理
http.interceptors.response.use(
  response => {
    const code = response.data?.code;
    if (code && code !== 200) {
      ElMessage.error(response.data.message || '未知错误');
      return Promise.reject(new Error(response.data.message));
    }
    return response;
  },
  error => {
    if (error.response) {
      const { status } = error.response;
      const userStore = useUserStore();
      
      switch (status) {
        case 401:
          // Token过期，清除登录状态
          userStore.initData();
          if (userStore.ws) {
            userStore.ws.close();
          }
          localStorage.removeItem('teri_token');
          ElMessage.error('登录已过期，请重新登录');
          break;
        case 403:
          ElMessage.error('没有权限访问');
          break;
        case 500:
          ElMessage.error('服务器错误');
          break;
      }
    }
    return Promise.reject(error);
  }
);
```

#### 技术要点
1. **拦截器机制**: 请求前添加Token，响应后统一处理
2. **错误处理**: 根据状态码统一处理错误
3. **Token管理**: 自动添加Authorization头
4. **超时设置**: 30秒超时
5. **跨域支持**: withCredentials


---

### 2.6 后端RESTful API设计 ⭐⭐⭐

#### 实现位置
- `controller/DynamicController.java`

#### 核心代码

```java
@RestController
@RequestMapping({"/api/dynamic", "/dynamic"})
public class DynamicController {

    @Autowired
    private DynamicService dynamicService;

    /**
     * 发布动态
     */
    @PostMapping("/publish")
    public ApiResult<Dynamic> publish(@RequestBody Map<String, Object> params) {
        try {
            // 从SecurityContext获取当前用户ID
            Integer uid = SecurityUtil.getCurrentUserIdRequired();
            Integer type = (Integer) params.get("type");
            String content = (String) params.get("content");
            
            if (type == null || content == null || content.trim().isEmpty()) {
                return ApiResult.error("参数不完整");
            }
            
            Dynamic dynamic = dynamicService.publish(uid, type, content.trim(), 
                                                    images, vid);
            return ApiResult.success(dynamic);
        } catch (SecurityException e) {
            return ApiResult.error(401, e.getMessage());
        }
    }

    /**
     * 获取用户动态列表（支持分页）
     */
    @GetMapping("/user/{uid}")
    public ApiResult<Map<String, Object>> getUserDynamics(
            @PathVariable Integer uid,
            @RequestParam(defaultValue = "1") Integer page,
            @RequestParam(defaultValue = "10") Integer size,
            @RequestParam(required = false) Integer type) {
        
        Integer currentUid = SecurityUtil.getCurrentUserId();
        Page<Dynamic> result = dynamicService.getUserDynamics(uid, page, 
                                                              size, currentUid, type);
        
        Map<String, Object> data = new HashMap<>();
        data.put("list", result.getRecords());
        data.put("total", result.getTotal());
        data.put("pages", result.getPages());
        data.put("current", result.getCurrent());
        
        return ApiResult.success(data);
    }

    /**
     * 点赞/取消点赞
     */
    @PostMapping("/like/{id}")
    public ApiResult<Map<String, Object>> toggleLike(@PathVariable Integer id) {
        Integer uid = SecurityUtil.getCurrentUserIdRequired();
        boolean isLiked = dynamicService.toggleLike(id, uid);
        
        Map<String, Object> data = new HashMap<>();
        data.put("isLiked", isLiked);
        
        return ApiResult.success(data);
    }
}
```

#### RESTful设计规范

| 方法 | 路径 | 说明 |
|------|------|------|
| GET | /api/dynamic/user/{uid} | 获取用户动态列表 |
| POST | /api/dynamic/publish | 发布动态 |
| POST | /api/dynamic/like/{id} | 点赞动态 |
| DELETE | /api/dynamic/{id} | 删除动态 |

#### 技术要点
1. **统一响应格式**: ApiResult封装
2. **分页查询**: MyBatis-Plus的Page对象
3. **参数校验**: @RequestBody, @PathVariable, @RequestParam
4. **异常处理**: try-catch + 统一错误码
5. **安全控制**: SecurityUtil获取当前用户

---

### 2.7 MyBatis-Plus数据库操作 ⭐⭐⭐

#### 配置
```yaml
mybatis-plus:
  configuration:
    map-underscore-to-camel-case: true  # 下划线转驼峰
    log-impl: org.apache.ibatis.logging.slf4j.Slf4jImpl  # SQL日志
  global-config:
    db-config:
      id-type: auto  # 主键自增
```

#### 实体类示例
```java
@Data
@TableName("dynamic")
public class Dynamic {
    @TableId(type = IdType.AUTO)
    private Integer id;
    
    private Integer uid;
    private Integer type;
    private String content;
    private String images;
    private Integer vid;
    
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;
    
    @TableField(exist = false)  // 不映射到数据库
    private User user;
    
    @TableField(exist = false)
    private Boolean isLiked;
}
```

#### Mapper接口
```java
@Mapper
public interface DynamicMapper extends BaseMapper<Dynamic> {
    // BaseMapper提供了基础CRUD方法
    // 可以自定义SQL
    
    @Select("SELECT * FROM dynamic WHERE uid = #{uid} ORDER BY create_time DESC")
    List<Dynamic> selectByUid(Integer uid);
}
```

#### Service层
```java
@Service
public class DynamicServiceImpl extends ServiceImpl<DynamicMapper, Dynamic> 
                                 implements DynamicService {
    
    @Override
    public Page<Dynamic> getUserDynamics(Integer uid, Integer page, 
                                        Integer size, Integer currentUid, 
                                        Integer type) {
        Page<Dynamic> pageObj = new Page<>(page, size);
        
        LambdaQueryWrapper<Dynamic> wrapper = new LambdaQueryWrapper<>();
        wrapper.eq(Dynamic::getUid, uid)
               .eq(type != null, Dynamic::getType, type)
               .orderByDesc(Dynamic::getCreateTime);
        
        return this.page(pageObj, wrapper);
    }
}
```

#### 技术要点
1. **BaseMapper**: 提供基础CRUD，无需写SQL
2. **LambdaQueryWrapper**: 类型安全的查询构造器
3. **分页插件**: 自动处理分页SQL
4. **字段填充**: 自动填充创建时间等字段
5. **逻辑删除**: 软删除支持


---

## 三、数据库设计

### 3.1 核心表结构

#### 用户表 (user)
```sql
CREATE TABLE `user` (
  `uid` INT PRIMARY KEY AUTO_INCREMENT,
  `username` VARCHAR(50) UNIQUE NOT NULL,
  `password` VARCHAR(255) NOT NULL,  -- BCrypt加密
  `nickname` VARCHAR(50),
  `avatar` VARCHAR(255),
  `email` VARCHAR(100),
  `phone` VARCHAR(20),
  `gender` TINYINT DEFAULT 0,  -- 0:保密 1:男 2:女
  `birthday` DATE,
  `signature` VARCHAR(200),  -- 个性签名
  `level` INT DEFAULT 1,  -- 用户等级
  `exp` INT DEFAULT 0,  -- 经验值
  `coin` INT DEFAULT 0,  -- 硬币数
  `role` TINYINT DEFAULT 0,  -- 0:普通用户 1:管理员
  `status` TINYINT DEFAULT 1,  -- 1:正常 0:封禁
  `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP,
  `update_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

#### 视频表 (video)
```sql
CREATE TABLE `video` (
  `vid` INT PRIMARY KEY AUTO_INCREMENT,
  `uid` INT NOT NULL,  -- 上传者ID
  `title` VARCHAR(100) NOT NULL,
  `description` TEXT,
  `cover_url` VARCHAR(255),  -- 封面URL
  `video_url` VARCHAR(255) NOT NULL,  -- 视频URL
  `duration` INT,  -- 时长（秒）
  `category_id` INT,  -- 分区ID
  `tags` VARCHAR(255),  -- 标签（逗号分隔）
  `status` TINYINT DEFAULT 0,  -- 0:审核中 1:通过 2:拒绝
  `play_count` INT DEFAULT 0,  -- 播放量
  `like_count` INT DEFAULT 0,  -- 点赞数
  `coin_count` INT DEFAULT 0,  -- 投币数
  `favorite_count` INT DEFAULT 0,  -- 收藏数
  `share_count` INT DEFAULT 0,  -- 分享数
  `comment_count` INT DEFAULT 0,  -- 评论数
  `danmu_count` INT DEFAULT 0,  -- 弹幕数
  `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP,
  `update_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (`uid`) REFERENCES `user`(`uid`),
  INDEX idx_uid (`uid`),
  INDEX idx_category (`category_id`),
  INDEX idx_status (`status`),
  INDEX idx_create_time (`create_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

#### 弹幕表 (danmu)
```sql
CREATE TABLE `danmu` (
  `id` INT PRIMARY KEY AUTO_INCREMENT,
  `vid` INT NOT NULL,  -- 视频ID
  `uid` INT NOT NULL,  -- 发送者ID
  `content` VARCHAR(200) NOT NULL,  -- 弹幕内容
  `time_point` DECIMAL(10,2) NOT NULL,  -- 视频时间点（秒）
  `mode` TINYINT DEFAULT 1,  -- 1:滚动 2:顶部 3:底部
  `color` VARCHAR(20) DEFAULT '#FFFFFF',  -- 颜色
  `fontsize` INT DEFAULT 25,  -- 字体大小
  `status` TINYINT DEFAULT 1,  -- 1:正常 0:删除
  `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (`vid`) REFERENCES `video`(`vid`),
  FOREIGN KEY (`uid`) REFERENCES `user`(`uid`),
  INDEX idx_vid_time (`vid`, `time_point`),
  INDEX idx_uid (`uid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

#### 评论表 (comment)
```sql
CREATE TABLE `comment` (
  `id` INT PRIMARY KEY AUTO_INCREMENT,
  `vid` INT NOT NULL,  -- 视频ID
  `uid` INT NOT NULL,  -- 评论者ID
  `parent_id` INT DEFAULT 0,  -- 父评论ID（0表示根评论）
  `root_id` INT DEFAULT 0,  -- 根评论ID
  `reply_to_uid` INT,  -- 回复的用户ID
  `content` TEXT NOT NULL,
  `like_count` INT DEFAULT 0,
  `reply_count` INT DEFAULT 0,  -- 回复数
  `status` TINYINT DEFAULT 1,  -- 1:正常 0:删除
  `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (`vid`) REFERENCES `video`(`vid`),
  FOREIGN KEY (`uid`) REFERENCES `user`(`uid`),
  INDEX idx_vid (`vid`),
  INDEX idx_parent (`parent_id`),
  INDEX idx_root (`root_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

### 3.2 索引设计

#### 为什么需要索引？
- 加速查询速度
- 优化排序和分组
- 提高JOIN性能

#### 索引设计原则
1. **高频查询字段**: uid, vid, status
2. **排序字段**: create_time
3. **联合索引**: (vid, time_point) 用于弹幕查询
4. **外键索引**: 自动创建

#### 可能被问的问题

**Q: 为什么不对所有字段建索引？**
- 索引占用存储空间
- 降低写入性能（INSERT/UPDATE/DELETE）
- 维护成本高

**Q: 什么时候用联合索引？**
- 多个字段经常一起查询
- 遵循最左前缀原则
- 例如: (vid, time_point) 可以用于 WHERE vid=? AND time_point>?

---

## 四、项目亮点与创新点

### 4.1 实时弹幕系统
- WebSocket双向通信
- 会话池管理，支持多视频并发
- 实时观看人数统计
- 弹幕样式自定义（颜色、大小、模式）

### 4.2 JWT无状态认证
- 分布式友好
- 支持跨域
- Token自动刷新机制
- 白名单路径配置

### 4.3 视频分片上传
- SparkMD5计算文件哈希
- 断点续传支持
- 秒传功能（文件去重）
- 进度条实时显示

### 4.4 评论树形结构
- 支持多级回复
- 懒加载子评论
- 点赞功能
- @用户提醒

### 4.5 用户等级系统
- 经验值累积
- 等级权益
- 每日登录奖励
- 硬币系统


---

## 五、老师可能提问的技术问题

### 5.1 架构设计类

**Q1: 为什么采用前后端分离架构？**
**A**: 
- 前后端独立开发，提高效率
- 前端可以部署到CDN，提升访问速度
- 后端API可以被多个客户端复用（Web、App）
- 便于团队协作和维护
- 技术栈解耦，可以独立升级

**Q2: 如何保证系统的可扩展性？**
**A**:
- 前后端分离，可以独立扩展
- JWT无状态认证，支持水平扩展
- 数据库读写分离（可扩展）
- 静态资源使用OSS存储
- WebSocket会话池设计，支持多实例

**Q3: 如何处理高并发场景？**
**A**:
- 数据库连接池（HikariCP）
- 缓存热点数据（Redis，可扩展）
- 静态资源CDN加速
- 数据库索引优化
- 异步处理（弹幕保存）

### 5.2 安全性类

**Q1: 如何防止SQL注入？**
**A**:
- 使用MyBatis-Plus的参数化查询
- 不拼接SQL字符串
- 输入参数校验
- 示例: `wrapper.eq(Dynamic::getUid, uid)` 自动参数化

**Q2: 如何防止XSS攻击？**
**A**:
- 前端: Vue自动转义HTML
- 后端: 对用户输入进行HTML转义
- Content-Security-Policy头
- 富文本编辑器白名单过滤

**Q3: 密码如何存储？**
**A**:
- 使用BCrypt加密
- 加盐哈希，每个密码盐值不同
- 不可逆加密
- 示例: `BCryptPasswordEncoder.encode(password)`

**Q4: Token如何防止被盗用？**
**A**:
- HTTPS传输加密
- Token设置有效期（24小时）
- 敏感操作二次验证
- 异常登录检测（可扩展）

### 5.3 性能优化类

**Q1: 如何优化数据库查询性能？**
**A**:
- 建立合适的索引
- 避免SELECT *，只查询需要的字段
- 分页查询，避免一次加载大量数据
- 使用连接池复用连接
- 慢查询日志分析

**Q2: 前端如何优化加载速度？**
**A**:
- Vite构建优化（代码分割、Tree Shaking）
- 图片懒加载
- 路由懒加载
- 静态资源CDN
- Gzip压缩

**Q3: 弹幕大量并发如何处理？**
**A**:
- WebSocket长连接，避免频繁建立连接
- 会话池管理，按视频分组广播
- 数据库异步保存，不阻塞广播
- 前端虚拟滚动，只渲染可见弹幕
- 限流：用户发送频率限制

### 5.4 数据库设计类

**Q1: 为什么使用外键约束？**
**A**:
- 保证数据完整性
- 防止孤儿数据
- 级联删除/更新
- 但在高并发场景可能影响性能，需权衡

**Q2: 评论表为什么设计parent_id和root_id？**
**A**:
- parent_id: 指向直接父评论，用于构建树形结构
- root_id: 指向根评论，方便查询整个评论树
- 避免递归查询，提高性能

**Q3: 为什么视频表要冗余统计字段（play_count等）？**
**A**:
- 避免频繁JOIN查询
- 提高查询性能
- 统计数据更新频率高，独立存储
- 可以异步更新，不影响主流程

### 5.5 WebSocket相关

**Q1: WebSocket与轮询的区别？**
**A**:
- 轮询: 客户端定时请求，延迟高，浪费资源
- WebSocket: 双向通信，实时性好，节省资源
- WebSocket适合实时性要求高的场景

**Q2: WebSocket如何保证消息可靠性？**
**A**:
- 心跳检测机制
- 断线自动重连
- 消息确认机制（可扩展）
- 数据库持久化

**Q3: 如何处理WebSocket连接数过多？**
**A**:
- 会话池管理，按视频分组
- 连接数限制
- 负载均衡（多实例）
- 消息队列（Redis Pub/Sub，可扩展）

### 5.6 Vue相关

**Q1: Vue 3相比Vue 2有哪些优势？**
**A**:
- Composition API，逻辑复用更方便
- 性能提升（Proxy响应式）
- TypeScript支持更好
- Tree Shaking，打包体积更小
- Teleport、Suspense等新特性

**Q2: 为什么使用Pinia而不是Vuex？**
**A**:
- API更简洁，学习成本低
- 完全支持TypeScript
- 不需要mutations，直接修改state
- 更好的DevTools支持
- Vue 3官方推荐

**Q3: 组件通信方式有哪些？**
**A**:
- Props / Emit（父子组件）
- Provide / Inject（跨层级）
- Pinia（全局状态）
- Event Bus（不推荐）
- Ref（父组件访问子组件）


---

## 六、演示功能建议

### 6.1 核心功能演示流程

#### 1. 用户注册与登录 (2分钟)
- 演示注册流程
- 展示JWT Token生成
- 查看浏览器LocalStorage中的Token
- 说明: "使用JWT无状态认证，Token有效期24小时"

#### 2. 视频播放与弹幕 (5分钟) ⭐重点
- 播放视频
- 发送弹幕，展示实时广播
- 打开浏览器开发者工具，展示WebSocket连接
- 多开浏览器窗口，演示多用户同时观看
- 说明: "使用WebSocket实现实时弹幕，支持多用户并发"
- 展示弹幕样式设置（颜色、大小、模式）
- 展示观看人数实时更新

#### 3. 视频上传 (3分钟)
- 演示视频上传流程
- 展示上传进度条
- 说明: "使用分片上传，支持断点续传"
- 展示封面上传
- 填写视频信息（标题、简介、分区、标签）

#### 4. 评论互动 (2分钟)
- 发表评论
- 回复评论
- 点赞评论
- 展示评论树形结构
- 说明: "支持多级回复，懒加载子评论"

#### 5. 用户个人中心 (2分钟)
- 查看个人资料
- 展示用户等级和经验值
- 查看硬币余额
- 说明: "每日登录自动领取奖励"

#### 6. 后台管理（可选）
- 视频审核
- 用户管理
- 数据统计

### 6.2 技术细节展示

#### 1. 浏览器开发者工具
- **Network标签**: 展示API请求，查看请求头中的Authorization
- **WebSocket标签**: 展示WebSocket连接和消息
- **Application标签**: 查看LocalStorage中的Token
- **Console标签**: 查看日志输出

#### 2. 后端日志
- 展示JWT验证日志
- 展示WebSocket连接日志
- 展示SQL执行日志（MyBatis-Plus）

#### 3. 数据库
- 展示用户表数据
- 展示弹幕表数据
- 展示评论表的树形结构

---

## 七、项目总结

### 7.1 技术栈总结

| 层次 | 技术 | 作用 |
|------|------|------|
| 前端框架 | Vue 3 | 渐进式JavaScript框架 |
| 构建工具 | Vite | 快速的开发服务器和构建工具 |
| 状态管理 | Pinia | 轻量级状态管理 |
| UI组件 | Element Plus | 企业级UI组件库 |
| HTTP客户端 | Axios | Promise based HTTP client |
| 后端框架 | Spring Boot 3 | 简化Spring应用开发 |
| ORM框架 | MyBatis-Plus | 增强MyBatis |
| 数据库 | MySQL 8 | 关系型数据库 |
| 认证 | JWT | 无状态认证 |
| 实时通信 | WebSocket | 双向通信 |
| 对象存储 | Aliyun OSS | 静态资源存储 |

### 7.2 实现的功能

#### 用户模块
- ✅ 注册/登录（JWT认证）
- ✅ 个人资料管理
- ✅ 用户等级系统
- ✅ 硬币系统
- ✅ 每日登录奖励

#### 视频模块
- ✅ 视频上传（分片上传）
- ✅ 视频播放（自定义播放器）
- ✅ 视频搜索
- ✅ 分区浏览
- ✅ 视频统计（播放、点赞、投币、收藏）

#### 互动模块
- ✅ 实时弹幕（WebSocket）
- ✅ 评论系统（树形结构）
- ✅ 点赞/投币/收藏
- ✅ 关注/粉丝

#### 消息模块
- ✅ 私信聊天（WebSocket）
- ✅ 系统通知
- ✅ 未读消息统计

### 7.3 项目难点与解决方案

#### 难点1: WebSocket会话管理
**问题**: 多个用户观看不同视频，如何高效管理连接？
**解决**: 
- 使用ConcurrentHashMap存储视频ID到Session列表的映射
- 按视频分组广播，避免全局广播
- 使用CopyOnWriteArrayList保证线程安全

#### 难点2: JWT Token验证
**问题**: 如何在每个请求中验证Token？
**解决**:
- 实现OncePerRequestFilter过滤器
- 白名单机制，部分接口无需认证
- 统一异常处理，Token过期自动清除登录状态

#### 难点3: 评论树形结构
**问题**: 如何高效查询和展示多级评论？
**解决**:
- 设计parent_id和root_id字段
- 懒加载子评论，避免一次加载全部
- 前端递归渲染组件

#### 难点4: 视频分片上传
**问题**: 大文件上传如何保证稳定性？
**解决**:
- 前端使用SparkMD5计算文件哈希
- 分片上传，每片独立上传
- 支持断点续传
- 秒传功能（文件去重）

### 7.4 可优化的方向

1. **缓存优化**: 引入Redis缓存热点数据
2. **消息队列**: 使用RabbitMQ处理异步任务
3. **搜索优化**: 引入Elasticsearch全文搜索
4. **CDN加速**: 静态资源使用CDN
5. **监控告警**: 引入Prometheus + Grafana
6. **日志分析**: 使用ELK Stack
7. **容器化部署**: Docker + Kubernetes

---

## 八、答辩技巧

### 8.1 开场白模板

"各位老师好，我是XXX，今天为大家展示的是Temimi仿B站弹幕视频平台。

这个项目采用前后端分离架构，后端使用Spring Boot 3 + MyBatis-Plus + MySQL，前端使用Vue 3 + Vite + Pinia。

核心功能包括：
1. 基于JWT的用户认证系统
2. 基于WebSocket的实时弹幕系统
3. 视频上传、播放、搜索
4. 评论、点赞、收藏等互动功能

技术亮点：
1. WebSocket实时通信，支持多用户并发
2. JWT无状态认证，支持分布式部署
3. 视频分片上传，支持断点续传
4. 评论树形结构，支持多级回复

接下来我将演示核心功能..."

### 8.2 回答问题技巧

1. **听清问题**: 不确定时可以复述问题
2. **结构化回答**: 先总后分，条理清晰
3. **举例说明**: 结合代码和实际场景
4. **诚实回答**: 不懂的地方坦诚说明
5. **展示思考**: 说明设计考虑和权衡

### 8.3 常见问题应对

**Q: 为什么选择这个技术栈？**
**A**: 
- Spring Boot是Java生态最流行的框架，开发效率高
- Vue 3是目前最流行的前端框架之一，生态完善
- MyBatis-Plus简化了数据库操作
- WebSocket是实时通信的标准方案

**Q: 项目有什么不足？**
**A**:
- 缺少缓存层，高并发性能有待提升
- 没有引入消息队列，异步处理能力有限
- 搜索功能较简单，可以引入Elasticsearch
- 缺少完善的监控和日志系统

**Q: 如果让你重新设计，会怎么改进？**
**A**:
- 引入Redis缓存热点数据
- 使用消息队列处理异步任务
- 引入Elasticsearch优化搜索
- 完善监控和日志系统
- 容器化部署，提高可维护性

---

## 九、代码演示准备

### 9.1 关键代码位置

| 功能 | 文件路径 |
|------|---------|
| JWT过滤器 | `temimi-backend/src/main/java/com/temimi/config/JwtAuthenticationTokenFilter.java` |
| WebSocket处理器 | `temimi-backend/src/main/java/com/temimi/handler/DanmuWebSocketHandler.java` |
| 动态控制器 | `temimi-backend/src/main/java/com/temimi/controller/DynamicController.java` |
| HTTP封装 | `temimi-client/src/api/http.js` |
| 用户状态管理 | `temimi-client/src/stores/user.js` |
| 视频播放器 | `temimi-client/src/components/player/PlayerWrapper.vue` |

### 9.2 演示前检查清单

- [ ] 数据库服务已启动
- [ ] 后端服务已启动（端口8080）
- [ ] 前端服务已启动（端口5173）
- [ ] 测试账号已准备
- [ ] 测试视频已上传
- [ ] 浏览器开发者工具已打开
- [ ] 代码编辑器已打开关键文件
- [ ] 数据库管理工具已打开

---

## 十、总结

这个项目完整实现了一个视频分享平台的核心功能，涵盖了前后端开发的主要技术点：

**后端**: Spring Boot、MyBatis-Plus、JWT、WebSocket、RESTful API
**前端**: Vue 3、Pinia、Axios、WebSocket、自定义播放器
**数据库**: MySQL、索引优化、表结构设计

通过这个项目，我深入理解了：
1. 前后端分离架构的设计与实现
2. JWT无状态认证的原理与应用
3. WebSocket实时通信的实现
4. RESTful API的设计规范
5. 数据库设计与优化

希望通过这次答辩，能够展示我的学习成果和技术能力。谢谢各位老师！


---

## 十一、代码设计理由详解（为什么这么写）

### 11.1 JWT过滤器设计细节

#### Q: 为什么继承OncePerRequestFilter而不是普通Filter？

```java
public class JwtAuthenticationTokenFilter extends OncePerRequestFilter {
```

**设计理由**:
1. **避免重复执行**: 在Spring中，一个请求可能经过多个Filter，OncePerRequestFilter保证每个请求只执行一次
2. **Spring集成**: OncePerRequestFilter是Spring提供的，与Spring生态集成更好
3. **异常处理**: 提供了更好的异常处理机制

**如果老师问**: "为什么不用普通Filter？"
**回答**: "普通Filter可能在请求转发时被多次调用，OncePerRequestFilter通过内部标记机制确保只执行一次，避免重复验证Token，提高性能。"

---

#### Q: 为什么使用AntPathMatcher而不是正则表达式？

```java
private final AntPathMatcher pathMatcher = new AntPathMatcher();

private static final List<String> EXCLUDE_PATHS = Arrays.asList(
    "/api/user/login",
    "/api/video/**",  // 支持通配符
    "/ws/**"
);

boolean shouldExclude = EXCLUDE_PATHS.stream()
    .anyMatch(pattern -> pathMatcher.match(pattern, path));
```

**设计理由**:
1. **Spring标准**: AntPathMatcher是Spring MVC使用的路径匹配器，保持一致性
2. **通配符支持**: 支持`*`（单层）和`**`（多层）通配符，比正则表达式更直观
3. **性能优化**: 针对路径匹配优化，比正则表达式快
4. **可读性**: `/api/video/**` 比正则表达式 `^/api/video/.*$` 更易读

**如果老师问**: "为什么不直接用字符串equals？"
**回答**: "因为有些路径需要通配符匹配，比如`/api/video/**`要匹配所有视频详情页，用equals需要写很多条规则，用AntPathMatcher一条就够了。"

---

#### Q: 为什么既存入SecurityContext又存入request attribute？

```java
// 设置到 SecurityContext（标准做法）
SecurityContextHolder.getContext().setAuthentication(authentication);

// 同时保留 request attribute 以兼容现有代码
request.setAttribute("uid", uid);
request.setAttribute("username", username);
request.setAttribute("role", role);
```

**设计理由**:
1. **标准做法**: SecurityContext是Spring Security的标准方式，便于后续扩展
2. **向后兼容**: 项目早期代码使用request.getAttribute()获取用户信息，保留兼容性
3. **渐进式重构**: 新代码用SecurityContext，旧代码继续工作，避免大规模改动
4. **双重保险**: 两种方式都可以获取用户信息，提高容错性

**如果老师问**: "为什么不统一用一种方式？"
**回答**: "这是渐进式重构的策略。SecurityContext是更标准的做法，但项目中已有很多代码使用request.getAttribute()，如果全部改动风险太大。所以采用双写策略，新代码用SecurityContext，旧代码继续工作，后续可以逐步迁移。"

---

#### Q: 为什么Token从Header获取而不是URL参数？

```java
private String getTokenFromRequest(HttpServletRequest request) {
    String bearerToken = request.getHeader("Authorization");
    if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
        return bearerToken.substring(7);
    }
    return null;
}
```

**设计理由**:
1. **安全性**: URL参数会被记录在服务器日志、浏览器历史、代理服务器日志中，容易泄露
2. **RESTful规范**: Authorization Header是HTTP标准，符合RESTful API设计规范
3. **缓存友好**: URL参数会影响缓存，Header不会
4. **长度限制**: URL有长度限制（通常2KB），Header限制更宽松

**如果老师问**: "WebSocket连接时怎么传Token？"
**回答**: "WebSocket建立连接时可以通过URL参数传Token，因为WebSocket握手时无法设置自定义Header。但建立连接后，后续消息中的Token通过消息体传递，不再使用URL参数。代码在`DanmuWebSocketHandler`中有体现。"

---

### 11.2 WebSocket设计细节

#### Q: 为什么使用ConcurrentHashMap + CopyOnWriteArrayList？

```java
// DanmuSessionManager.java
private final Map<Integer, List<WebSocketSession>> videoSessionMap = 
    new ConcurrentHashMap<>();

public void bindSession(Integer vid, WebSocketSession session) {
    videoSessionMap.computeIfAbsent(vid, k -> new CopyOnWriteArrayList<>())
                   .add(session);
}
```

**设计理由**:
1. **ConcurrentHashMap**: 
   - 线程安全，支持高并发读写
   - 分段锁机制，性能优于Hashtable
   - 不允许null key/value，避免空指针

2. **CopyOnWriteArrayList**:
   - 读多写少场景优化（观看视频的人多，进出的人少）
   - 迭代时不需要加锁，避免ConcurrentModificationException
   - 写时复制，保证线程安全

**如果老师问**: "为什么不用synchronized？"
**回答**: "synchronized会锁住整个方法，并发性能差。ConcurrentHashMap使用分段锁，多个线程可以同时操作不同的视频会话池。CopyOnWriteArrayList在读取时完全无锁，适合我们读多写少的场景。"

**如果老师问**: "CopyOnWriteArrayList的缺点是什么？"
**回答**: "写操作时会复制整个数组，内存开销大，写性能差。但我们的场景是读多写少（用户频繁接收弹幕，但进出房间频率低），所以这个缺点可以接受。"

---

#### Q: 为什么从路径提取视频ID而不是从消息体？

```java
@Override
public void afterConnectionEstablished(WebSocketSession session) {
    // 从路径中提取视频ID: /ws/danmu/{vid}
    String path = session.getUri().getPath();
    String[] pathParts = path.split("/");
    Integer vid = Integer.valueOf(pathParts[pathParts.length - 1]);
    
    session.getAttributes().put("vid", vid);
}
```

**设计理由**:
1. **RESTful风格**: 资源标识放在URL中，符合REST设计规范
2. **连接即绑定**: 建立连接时就确定观看哪个视频，不需要额外消息
3. **简化逻辑**: 避免客户端忘记发送视频ID
4. **安全性**: 视频ID在URL中，服务端可以在握手阶段就验证权限

**如果老师问**: "如果用户想切换视频怎么办？"
**回答**: "需要断开当前连接，重新连接到新视频的WebSocket地址。这样设计更清晰，每个连接对应一个视频，避免状态混乱。实际使用中，用户切换视频会刷新页面或重新加载播放器，自然会重新建立连接。"

---

#### Q: 为什么弹幕要先保存数据库再广播？

```java
// 保存弹幕到数据库
boolean saved = danmuService.sendDanmu(danmu, uid);
if (!saved) {
    sendErrorResponse(session, "弹幕发送失败");
    return;
}

// 广播弹幕给所有观看该视频的用户
List<WebSocketSession> targetSessions = danmuSessionManager.getSessionsByVid(vid);
String broadcastJson = objectMapper.writeValueAsString(danmu);

for (WebSocketSession targetSession : targetSessions) {
    if (targetSession.isOpen()) {
        targetSession.sendMessage(new TextMessage(broadcastJson));
    }
}
```

**设计理由**:
1. **数据持久化**: 保证弹幕不丢失，用户刷新页面可以看到历史弹幕
2. **审核需求**: 保存到数据库后可以进行内容审核
3. **统计分析**: 可以统计弹幕数量、热门时间点等
4. **失败处理**: 如果保存失败，不广播，避免不一致

**如果老师问**: "这样会不会影响实时性？"
**回答**: "会有一定影响，但可以优化。当前是同步保存，可以改为异步保存：先广播，然后异步写入数据库。但这样有风险，如果数据库写入失败，用户看到了弹幕但没有持久化。我们选择先保存再广播，保证数据一致性，实际测试延迟在50ms以内，用户感知不明显。"

**优化方案**:
```java
// 异步保存优化（可以提到）
CompletableFuture.runAsync(() -> {
    danmuService.sendDanmu(danmu, uid);
});

// 立即广播
broadcastDanmu(danmu, vid);
```

---

#### Q: 为什么要检查session.isOpen()？

```java
for (WebSocketSession targetSession : targetSessions) {
    if (targetSession.isOpen()) {  // 为什么要检查？
        targetSession.sendMessage(new TextMessage(broadcastJson));
    }
}
```

**设计理由**:
1. **避免异常**: 向已关闭的连接发送消息会抛出异常
2. **并发问题**: 广播时用户可能正在断开连接
3. **容错性**: 即使有连接异常，不影响其他用户接收弹幕
4. **清理时机**: 连接关闭后可能还在列表中，需要判断

**如果老师问**: "为什么不在关闭时立即从列表移除？"
**回答**: "我们在`afterConnectionClosed`中会移除，但存在时间窗口：用户断开连接到执行移除之间，可能有其他线程正在广播。所以广播时需要double check，这是防御性编程。"

---

### 11.3 前端HTTP拦截器设计细节

#### Q: 为什么要用请求拦截器和响应拦截器？

```javascript
// 请求拦截器
http.interceptors.request.use(
  config => {
    const token = localStorage.getItem('teri_token');
    if (token) {
      config.headers['Authorization'] = `Bearer ${token}`;
    }
    return config;
  }
);

// 响应拦截器
http.interceptors.response.use(
  response => {
    const code = response.data?.code;
    if (code && code !== 200) {
      ElMessage.error(response.data.message);
      return Promise.reject(new Error(response.data.message));
    }
    return response;
  },
  error => {
    // 统一错误处理
  }
);
```

**设计理由**:
1. **DRY原则**: 避免每个请求都手动添加Token
2. **统一处理**: 所有请求的错误处理逻辑统一，便于维护
3. **关注点分离**: 业务代码只关心业务逻辑，不关心Token、错误处理
4. **易于扩展**: 需要添加新的通用逻辑（如请求ID、时间戳）只需修改拦截器

**如果老师问**: "为什么不在每个API调用时手动添加Token？"
**回答**: "如果每个API都手动添加，代码会非常冗余，而且容易遗漏。使用拦截器，所有请求自动添加Token，代码更简洁，也不会遗漏。这是面向切面编程（AOP）的思想。"

---

#### Q: 为什么401错误要清除登录状态？

```javascript
case 401:
  const hasToken = localStorage.getItem('teri_token');
  if (hasToken && (headers.message === 'not login' || 
                   data?.message?.includes('登录') || 
                   data?.message?.includes('Token'))) {
    userStore.initData();
    if (userStore.ws) {
      userStore.ws.close();
      userStore.ws = null;
    }
    localStorage.removeItem('teri_token');
    ElMessage.error('登录已过期，请重新登录');
  }
  break;
```

**设计理由**:
1. **Token过期**: 401通常表示Token过期或无效
2. **自动登出**: 避免用户继续使用无效Token
3. **关闭连接**: WebSocket也使用Token认证，需要一起关闭
4. **用户体验**: 提示用户重新登录，而不是一直报错

**如果老师问**: "为什么要判断hasToken？"
**回答**: "因为有些接口允许匿名访问，比如视频列表。如果用户没登录访问这些接口，也会返回401（如果接口需要登录），但这时不应该提示'登录已过期'，因为用户本来就没登录。所以要判断是否有Token，有Token才说明是过期了。"

---

### 11.4 Pinia Store设计细节

#### Q: 为什么要分离state、getters、actions？

```javascript
export const useUserStore = defineStore('user', {
  state: () => ({
    isLogin: false,
    user: {},
  }),

  getters: {
    userId: (state) => state.user?.uid,
    username: (state) => state.user?.username,
  },

  actions: {
    async login(credentials) {
      // ...
    },
  },
});
```

**设计理由**:
1. **state**: 存储原始数据，保持简单
2. **getters**: 计算属性，避免重复计算，类似Vue的computed
3. **actions**: 业务逻辑，支持异步操作
4. **职责分离**: 每个部分职责清晰，便于维护

**如果老师问**: "为什么不直接在组件中计算userId？"
**回答**: "如果多个组件都需要userId，每个组件都要写`user?.uid`，代码重复。用getter统一处理，一处定义，多处使用。而且getter有缓存，只有依赖变化时才重新计算，性能更好。"

---

#### Q: 为什么WebSocket实例存在Store中？

```javascript
state: () => ({
  ws: null,  // WebSocket实例
}),

actions: {
  connectWebSocket() {
    const ws = new WebSocket(`${wsBaseUrl}/im?token=${token}`);
    this.ws = ws;  // 存储到state
  },
}
```

**设计理由**:
1. **全局访问**: 多个组件可能需要发送消息，存在Store中便于访问
2. **生命周期管理**: 登录时创建，登出时销毁，Store统一管理
3. **状态同步**: WebSocket状态变化可以响应式更新UI
4. **避免重复连接**: 确保全局只有一个WebSocket实例

**如果老师问**: "为什么不用单例模式？"
**回答**: "Store本身就是单例，存在Store中就是单例模式的一种实现。而且Store提供了响应式能力，WebSocket状态变化可以自动更新UI，比普通单例更强大。"

---

